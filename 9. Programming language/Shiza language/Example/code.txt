push 10000
pop rax
push 20000
pop rbx
push 30000
pop rcx
push 40000
pop rdx
push 0
pop rex

push 8 // push the number


push rex // put the out-number of stack into the variable
push 30
mul
push 0
add
push rax
add
pop rbx
pop [rbx]

push 3 // push the number


push rex // put the out-number of stack into the variable
push 30
mul
push 1
add
push rax
add
pop rbx
pop [rbx]

push 0 // push the number


push rex // put the out-number of stack into the variable
push 30
mul
push 2
add
push rax
add
pop rbx
pop [rbx]

while_0000000000924C70:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 10 // push the number

jae :end_while_0000000000924AC0 // if the first expr is less than the second, do the next->

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :fibonach // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex
out
pop
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 1 // push the number

add


push rex // put the out-number of stack into the variable
push 30
mul
push 2
add
push rax
add
pop rbx
pop [rbx]

jump :while_0000000000924C70 // check the while-condition again
end_while_0000000000924AC0:
push 0 // push the number


push rex // put the out-number of stack into the variable
push 30
mul
push 2
add
push rax
add
pop rbx
pop [rbx]

while_0000000000A48A20:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 10 // push the number

jae :end_while_0000000000A48810 // if the first expr is less than the second, do the next->

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :factorial // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex
out
pop
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 1 // push the number

add


push rex // put the out-number of stack into the variable
push 30
mul
push 2
add
push rax
add
pop rbx
pop [rbx]

jump :while_0000000000A48A20 // check the while-condition again
end_while_0000000000A48810:
push 0 // push the number


push rex // put the out-number of stack into the variable
push 30
mul
push 5
add
push rax
add
pop rbx
pop [rbx]

push 0 // push the number


push rex // put the out-number of stack into the variable
push 30
mul
push 6
add
push rax
add
pop rbx
pop [rbx]

push 0 // push the number


push rex // put the out-number of stack into the variable
push 30
mul
push 2
add
push rax
add
pop rbx
pop [rbx]

in // scan the variable
push rex
push 30
mul
push 5
add
push rax
add
pop rbx
pop [rbx]

in // scan the variable
push rex
push 30
mul
push 6
add
push rax
add
pop rbx
pop [rbx]

in // scan the variable
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
pop [rbx]

// push the variable:
push rex
push 30
mul
push 5
add
push rax
add
pop rbx
push [rbx]

// push the variable:
push rex
push 30
mul
push 6
add
push rax
add
pop rbx
push [rbx]

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :solve_square // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex

hlt

factorial:

push rex
push 30
mul
push 0
add
push rax
add
pop rbx

pop [rbx + 0] // gets all parametres from parent-function

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 1 // push the number

jne :end_if_0000000000A495F0 // if two expression are equal, do the next:

// put the expression in stack and return:

push 1 // push the number

ret // return from the func

end_if_0000000000A495F0:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jne :end_if_0000000000A49AA0 // if two expression are equal, do the next:

// put the expression in stack and return:

push 1 // push the number

ret // return from the func

end_if_0000000000A49AA0:
// put the expression in stack and return:

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

push 1 // push the number

sub

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :factorial // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex
// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

push 1 // push the number

sub

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :factorial // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex
mul

add

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

push 1 // push the number

sub

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :factorial // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex
sub

ret // return from the func

fibonach:

push rex
push 30
mul
push 0
add
push rax
add
pop rbx

pop [rbx + 0] // gets all parametres from parent-function

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jne :end_if_0000000000A4A310 // if two expression are equal, do the next:

// put the expression in stack and return:

push 0 // push the number

ret // return from the func

end_if_0000000000A4A310:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 1 // push the number

jne :end_if_0000000000A4A910 // if two expression are equal, do the next:

// put the expression in stack and return:

push 1 // push the number

ret // return from the func

end_if_0000000000A4A910:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 1 // push the number

sub


push rex // put the out-number of stack into the variable
push 30
mul
push 1
add
push rax
add
pop rbx
pop [rbx]

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

push 2 // push the number

sub


push rex // put the out-number of stack into the variable
push 30
mul
push 2
add
push rax
add
pop rbx
pop [rbx]

// push the variable:
push rex
push 30
mul
push 1
add
push rax
add
pop rbx
push [rbx]

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :fibonach // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex
// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

push 1 // shift the local-variables address to start the next function
push rex
add
pop rex
call :fibonach // call the function
push rex // shift backwards the local-variables address to end the previous function
push 1
sub
pop rex
add


push rex // put the out-number of stack into the variable
push 30
mul
push 3
add
push rax
add
pop rbx
pop [rbx]

// put the expression in stack and return:

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

ret // return from the func

solve_square:

push rex
push 30
mul
push 0
add
push rax
add
pop rbx

pop [rbx + 2] // gets all parametres from parent-function
pop [rbx + 1] // gets all parametres from parent-function
pop [rbx + 0] // gets all parametres from parent-function

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jne :end_if_0000000000A4B330 // if two expression are equal, do the next:

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 1
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jne :end_if_0000000000A4B3C0 // if two expression are equal, do the next:

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jne :end_if_0000000000A4B8A0 // if two expression are equal, do the next:

push -1 // push the number

out
pop
ret // return from the func

end_if_0000000000A4B8A0:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

je :end_if_0000000000A4B780 // if two expression are not equal, do the next:

push 0 // push the number

out
pop
ret // return from the func

end_if_0000000000A4B780:
end_if_0000000000A4B3C0:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 1
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

je :end_if_0000000000A4C200 // if two expression are not equal, do the next:

push 1 // push the number

out
pop
push -1 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

// push the variable:
push rex
push 30
mul
push 1
add
push rax
add
pop rbx
push [rbx]

div

mul

out
pop
ret // return from the func

end_if_0000000000A4C200:
end_if_0000000000A4B330:
push 4 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

push 3 // push the number

pow

mul

push 0 // push the number

je :end_if_0000000000A4BFC0 // if two expression are not equal, do the next:

// push the variable:
push rex
push 30
mul
push 1
add
push rax
add
pop rbx
push [rbx]

push 2 // push the number

pow

push 4 // push the number

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 2
add
push rax
add
pop rbx
push [rbx]

mul

mul

push 2 // push the number

mul

push 4 // push the number

div

sub


push rex // put the out-number of stack into the variable
push 30
mul
push 3
add
push rax
add
pop rbx
pop [rbx]

push -1 // push the number

// push the variable:
push rex
push 30
mul
push 1
add
push rax
add
pop rbx
push [rbx]

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

div

push 2 // push the number

mul

push 4 // push the number

div

mul


push rex // put the out-number of stack into the variable
push 30
mul
push 4
add
push rax
add
pop rbx
pop [rbx]

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jae :end_if_0000000000A4CD70 // if the first expr is less than the second, do the next:

push 0 // push the number

out
pop
ret // return from the func

end_if_0000000000A4CD70:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jne :end_if_0000000000A4C830 // if two expression are equal, do the next:

push 1 // push the number

out
pop
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 4
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

out
pop
ret // return from the func

end_if_0000000000A4C830:
push 2 // push the number

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

mul

push 0 // push the number

jbe :end_if_0000000000A4D160 // if the first expr is greater than the second, do the next:

push 1.5 // push the number

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

push 0.5 // push the number

pow

mul

push 3 // push the number

mul

push 9 // push the number

div


push rex // put the out-number of stack into the variable
push 30
mul
push 3
add
push rax
add
pop rbx
pop [rbx]

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

// push the variable:
push rex
push 30
mul
push 0
add
push rax
add
pop rbx
push [rbx]

div


push rex // put the out-number of stack into the variable
push 30
mul
push 3
add
push rax
add
pop rbx
pop [rbx]

push 2 // push the number

out
pop
// push the variable:
push rex
push 30
mul
push 4
add
push rax
add
pop rbx
push [rbx]

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

add

out
pop
// push the variable:
push rex
push 30
mul
push 4
add
push rax
add
pop rbx
push [rbx]

push 2 // push the number

// push the variable:
push rex
push 30
mul
push 3
add
push rax
add
pop rbx
push [rbx]

mul

push 2 // push the number

mul

push 4 // push the number

div

sub

out
pop
end_if_0000000000A4D160:
end_if_0000000000A4BFC0:
ret // return from the func

